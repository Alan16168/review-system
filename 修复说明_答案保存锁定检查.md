# 答案保存锁定检查 - 修复说明

## 修复日期
2025-11-27

## 问题描述
用户报告在 Review 275 保存答案时出现 500 错误：
```
操作失败: Failed to update answer set
AxiosError: Request failed with status code 500
```

API 请求：`PUT /api/answer-sets/275/1`

## 根本原因分析

### 数据库验证
查询生产数据库发现 Review 275 的答案组状态为**已锁定**：

```sql
SELECT id, review_id, user_id, set_number, is_locked 
FROM review_answer_sets 
WHERE review_id = 275 AND user_id = 4

-- 结果:
{
  "id": 122,
  "review_id": 275,
  "user_id": 4,
  "set_number": 1,
  "is_locked": "yes"  ← 答案组已锁定
}
```

### 问题根源
1. **答案组已被锁定**：`is_locked: "yes"`
2. **前端没有阻止保存**：用户仍然可以编辑并尝试保存答案
3. **后端拒绝请求**：后端检测到锁定状态，返回 403 Forbidden
4. **错误处理不当**：前端将 403 错误显示为 500 错误

### 为什么前端没有禁用输入？
虽然代码中有 `updateAnswerEditability(isLocked)` 函数来禁用输入字段，但可能存在以下问题：
- 页面加载时锁定状态未正确传递
- 异步操作导致锁定状态更新延迟
- 某些输入字段未被正确选择器匹配

## 解决方案

### 多层防御策略
在前端添加**双重保护**：
1. UI 层面禁用输入（已存在）
2. **保存前验证锁定状态**（新增）

### 修改的函数
在所有答案保存函数中添加锁定状态检查：

1. ✅ `saveInlineAnswer` - 保存内联答案
2. ✅ `updateAnswerInSet` - 更新单选答案
3. ✅ `updateMultipleChoiceInSet` - 更新多选答案
4. ✅ `autoSaveDateTimeValue` - 自动保存日期时间值
5. ✅ `autoSaveDateTimeTitleAndAnswer` - 自动保存日期时间标题和答案

### 修改模式

**修改前**：
```javascript
const currentSet = sets[index];
const setNumber = parseInt(currentSet.set_number);

// 直接调用 API
await axios.put(`/api/answer-sets/${reviewId}/${setNumber}`, ...);
```

**修改后**：
```javascript
const currentSet = sets[index];
const setNumber = parseInt(currentSet.set_number);

console.log('[functionName] 锁定状态:', currentSet.is_locked);

// 检查锁定状态
if (currentSet.is_locked === 'yes') {
  console.error('[functionName] Answer set is locked');
  showNotification(i18n.t('answerSetIsLocked') || '当前答案组已锁定，无法编辑。请先解锁。', 'warning');
  return;
}

// 继续验证和保存
if (isNaN(setNumber)) {
  console.error('[functionName] Invalid set number:', currentSet.set_number);
  showNotification('Invalid answer set number', 'error');
  return;
}

// 调用 API
await axios.put(`/api/answer-sets/${reviewId}/${setNumber}`, ...);
```

## 修改的文件
`public/static/app.js`

## 详细修改内容

### 1. saveInlineAnswer（行 ~14816）
```javascript
console.log('[saveInlineAnswer] Lock status:', currentSet.is_locked);

// Check if answer set is locked
if (currentSet.is_locked === 'yes') {
  console.error('[saveInlineAnswer] Answer set is locked');
  showNotification(i18n.t('answerSetIsLocked') || '当前答案组已锁定，无法编辑。请先解锁。', 'warning');
  return;
}
```

### 2. updateAnswerInSet（行 ~14912）
```javascript
console.log('[updateAnswerInSet] 锁定状态:', currentSet.is_locked);

// Check if answer set is locked
if (currentSet.is_locked === 'yes') {
  console.error('[updateAnswerInSet] Answer set is locked');
  showNotification(i18n.t('answerSetIsLocked') || '当前答案组已锁定，无法编辑。请先解锁。', 'warning');
  return;
}
```

### 3. updateMultipleChoiceInSet（行 ~15013）
```javascript
console.log('[updateMultipleChoiceInSet] 锁定状态:', currentSet.is_locked);

// Check if answer set is locked
if (currentSet.is_locked === 'yes') {
  console.error('[updateMultipleChoiceInSet] Answer set is locked');
  showNotification(i18n.t('answerSetIsLocked') || '当前答案组已锁定，无法编辑。请先解锁。', 'warning');
  return;
}
```

### 4. autoSaveDateTimeValue（行 ~14253）
```javascript
// Check if answer set is locked
if (currentSet.is_locked === 'yes') {
  console.error('[autoSaveDateTimeValue] Answer set is locked');
  showNotification(i18n.t('answerSetIsLocked') || '当前答案组已锁定，无法编辑。请先解锁。', 'warning');
  return;
}
```

### 5. autoSaveDateTimeTitleAndAnswer（行 ~15087）
```javascript
// Check if answer set is locked
if (currentSet.is_locked === 'yes') {
  console.error('[autoSaveDateTimeTitleAndAnswer] Answer set is locked');
  showNotification(i18n.t('answerSetIsLocked') || '当前答案组已锁定，无法编辑。请先解锁。', 'warning');
  return;
}
```

## 防御层次

### 第一层：UI 禁用（已存在）
`updateAnswerEditability(isLocked)` 函数：
- 禁用所有答案输入字段
- 添加视觉提示（灰色背景、禁用光标）
- 禁用编辑按钮
- 点击时显示提示

### 第二层：保存前验证（新增）⭐
在每个保存函数中：
- 显式检查 `currentSet.is_locked === 'yes'`
- 如果锁定，立即返回并显示友好提示
- 记录错误日志便于调试

### 第三层：后端验证（已存在）
后端 API (`src/routes/answer_sets.ts`)：
```typescript
// Check if answer set is locked
if (set.is_locked === 'yes') {
  return c.json({ 
    error: 'This answer set is locked and cannot be edited. Please unlock it first.',
    is_locked: 'yes'
  }, 403);
}
```

## 用户体验改进

### 修复前
1. 用户编辑已锁定的答案组
2. 前端可能没有正确禁用输入
3. 用户点击保存
4. 后端返回 403 错误
5. 前端显示："操作失败: Failed to update answer set"
6. 用户困惑：不知道为什么失败

### 修复后
1. 用户编辑已锁定的答案组
2. UI 层面应该已禁用输入（第一层保护）
3. 如果用户绕过 UI 限制尝试保存
4. **JavaScript 立即检测锁定状态**
5. **显示清晰提示**："当前答案组已锁定，无法编辑。请先解锁。"
6. 不会发送 API 请求，避免不必要的网络流量

## 测试场景

### 测试1: 锁定答案组的保存尝试（主要场景）⭐
1. 进入 Review 275 的编辑页面
2. 确认答案组状态为"已锁定"
3. 尝试编辑并保存任意答案
4. **预期**：
   - ❌ 输入字段应该被禁用（灰色）
   - ❌ 如果强制编辑（通过开发者工具），保存时显示警告
   - ✅ 显示提示："当前答案组已锁定，无法编辑。请先解锁。"
   - ✅ 控制台显示："[functionName] Answer set is locked"
   - ❌ 不发送 API 请求

### 测试2: 解锁后正常保存
1. 在 Review 275 中点击"解锁"按钮
2. 答案组解锁后
3. 编辑并保存答案
4. **预期**：
   - ✅ 输入字段变为可编辑（白色背景）
   - ✅ 保存成功
   - ✅ 显示："答案已保存"

### 测试3: 单选/多选题（锁定状态）
1. 答案组已锁定
2. 尝试选择单选或多选选项
3. **预期**：
   - ❌ 选项应该被禁用
   - ❌ 如果触发 change 事件，显示锁定警告

### 测试4: 日期时间字段（锁定状态）
1. 答案组已锁定
2. 尝试修改日期时间字段
3. **预期**：
   - ❌ 字段应该被禁用
   - ❌ 如果触发保存，显示锁定警告

### 测试5: 控制台日志验证
1. 打开浏览器控制台
2. 尝试保存已锁定的答案组
3. **预期**：
   - ✅ 看到："[saveInlineAnswer] Lock status: yes"
   - ✅ 看到："[saveInlineAnswer] Answer set is locked"
   - ❌ 看不到 API 请求日志

## 部署信息
- **测试环境**: https://b1d99583.review-system.pages.dev
- **生产环境**: https://review-system.pages.dev
- **GitHub提交**: dbc0445 - "修复: 在所有答案保存函数中添加锁定状态检查"
- **修改文件**: `public/static/app.js`
- **修改行数**: 38 行插入

## 后续建议

### 1. 检查 UI 禁用逻辑
如果测试发现输入字段在锁定状态下仍然可编辑，需要检查：
- `updateAnswerEditability` 函数的选择器
- 确保所有输入类型都被正确选择
- 检查动态生成的输入是否被覆盖

### 2. 改进错误处理
当前前端将所有错误都显示为通用错误消息。建议：
```javascript
catch (error) {
  if (error.response?.status === 403) {
    showNotification('答案组已锁定，无法编辑', 'warning');
  } else if (error.response?.status === 404) {
    showNotification('答案组不存在', 'error');
  } else {
    showNotification('保存失败: ' + (error.response?.data?.error || '未知错误'), 'error');
  }
}
```

### 3. 定期同步锁定状态
考虑添加轮询或 WebSocket，实时同步答案组的锁定状态，防止多用户冲突。

## 技术细节

### 锁定状态的来源
```javascript
// 从 window.currentAnswerSets 获取
const currentSet = window.currentAnswerSets[window.currentSetIndex];

// currentSet 结构示例
{
  set_number: 1,
  created_at: "2025-11-20 10:00:00",
  updated_at: "2025-11-27 07:00:00",
  is_locked: "yes",  // ← 关键字段
  locked_at: "2025-11-27 07:00:00",
  locked_by: 4,
  answers: [...]
}
```

### 为什么需要在每个函数中检查？
虽然 UI 层面有禁用逻辑，但：
1. JavaScript 可以被绕过（开发者工具）
2. 异步操作可能导致状态不一致
3. 多层防御提高健壮性
4. 提供更好的用户体验（即时反馈）

## 总结
此次修复通过在所有答案保存函数中添加显式的锁定状态检查，确保了：
1. ✅ 锁定的答案组无法被修改（即使绕过 UI）
2. ✅ 用户收到清晰的错误提示
3. ✅ 避免不必要的 API 请求
4. ✅ 详细的调试日志便于问题诊断
5. ✅ 符合多层防御的安全最佳实践

**重要提示**：如果 Review 275 的答案组需要编辑，请先点击"解锁"按钮！
